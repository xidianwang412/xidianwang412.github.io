<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Notes</title>
  
  <subtitle>改变自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-07T09:36:21.513Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ylwang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tensorflow 笔记</title>
    <link href="http://yoursite.com/2018/10/06/Tensorflow-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/06/Tensorflow-笔记/</id>
    <published>2018-10-06T15:44:37.000Z</published>
    <updated>2018-10-07T09:36:21.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tensorflow之函数"><a href="#Tensorflow之函数" class="headerlink" title="Tensorflow之函数"></a>Tensorflow之函数</h1><h2 id="1-生成函数"><a href="#1-生成函数" class="headerlink" title="1. 生成函数"></a>1. 生成函数</h2><center><strong>Tensorflow随机数生成函数</strong></center><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">随机数分布</th><th style="text-align:center">主要参数</th></tr></thead><tbody><tr><td style="text-align:left">tf.random_normal</td><td style="text-align:left">正太分布</td><td style="text-align:center">平均值、标准差、取值类型</td></tr><tr><td style="text-align:left">tf.truncated_normal</td><td style="text-align:left">正太分布，但如果随机出来的值超过2个标准差，则这个数将被重新随机</td><td style="text-align:center">平均值、标准差、取值类型</td></tr><tr><td style="text-align:left">tf.random_uniform</td><td style="text-align:left">平均分布</td><td style="text-align:center">最小、最大取值，取值类型</td></tr><tr><td style="text-align:left">tf.random_gamma</td><td style="text-align:left">Gamma分布</td><td style="text-align:center">形状参数alpha、尺度参数beta、取值类型</td></tr></tbody></table><center><strong>Tensorflow常数生成函数</strong></center><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">功能</th><th style="text-align:center">样例</th></tr></thead><tbody><tr><td style="text-align:center">tf.zeros</td><td style="text-align:center">产生全0数组</td><td style="text-align:center">tf.zeros([2,3], int32) -&gt; [[0,0,0], [0,0,0]]</td></tr><tr><td style="text-align:center">tf.ones</td><td style="text-align:center">产生全1数组</td><td style="text-align:center">tf.ones([2,3], int32) -&gt; [[1,1,1], [1,1,1]]</td></tr><tr><td style="text-align:center">tf.fill</td><td style="text-align:center">产生一个全部为给定数字的数组</td><td style="text-align:center">tf.fill([2,3], 2) -&gt; [[2,2,2], [2,2,2]]</td></tr><tr><td style="text-align:center">tf.constant</td><td style="text-align:center">产生一个给定值的常量</td><td style="text-align:center">tf.constant([1, 2, 3]) -&gt; [1,2,3]</td></tr></tbody></table><h2 id="2-交叉熵函数"><a href="#2-交叉熵函数" class="headerlink" title="2. 交叉熵函数"></a>2. 交叉熵函数</h2><p>TensorFlow针对分类问题，实现了四个交叉熵函数，分别是</p><ul><li>tf.nn.sigmoid_cross_entropy_with_logits</li><li>tf.nn.softmax_cross_entropy_with_logits</li><li>tf.nn.sparse_softmax_cross_entropy_with_logits</li><li>tf.nn.weighted_cross_entropy_with_logits</li></ul><p><a href="https://tensorflow.google.cn/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits" target="_blank" rel="noopener">详细内容参考官方API文档</a></p><p><strong>注意：tensorflow交叉熵计算函数输入中的logits都不是softmax或sigmoid的输出，而是softmax或sigmoid函数的输入，因为它在函数内部进行sigmoid或softmax操作</strong></p><h3 id="1-tf-nn-sigmoid-cross-entropy-with-logits"><a href="#1-tf-nn-sigmoid-cross-entropy-with-logits" class="headerlink" title="(1) tf.nn.sigmoid_cross_entropy_with_logits"></a>(1) tf.nn.sigmoid_cross_entropy_with_logits</h3><pre><code>tf.nn.sigmoid_cross_entropy_with_logits(_sentinel=None,labels=None,logits=None,name=None)</code></pre><ul><li>计算方式：对输入的logits先通过sigmoid函数计算，再计算它们的交叉熵，但是它对交叉熵的计算方式进行了优化，使得的结果不至于溢出</li><li>适用：每个类别相互独立但互不排斥的情况：例如一幅图可以同时包含一条狗和一只大象</li><li>输入：<br>(1) logits: 数据类型（type）是float32或float64，维度(shape)为[batch_size,num_classes]<br>(2) labels: 和logits具有相同的type(float)和shape的张量(tensor)</li><li>输出：<br>loss， shape:[batch_size,num_classes]</li></ul><h3 id="（2）-tf-nn-softmax-cross-entropy-with-logits"><a href="#（2）-tf-nn-softmax-cross-entropy-with-logits" class="headerlink" title="（2） tf.nn.softmax_cross_entropy_with_logits"></a>（2） tf.nn.softmax_cross_entropy_with_logits</h3><pre><code>tf.nn.softmax_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, dim=-1, name=None)</code></pre><ul><li>计算方式：对输入的logits先通过softmax函数计算，再计算它们的交叉熵，但是它对交叉熵的计算方式进行了优化，使得结果不至于溢出</li><li>适用：每个类别相互独立且排斥的情况，一幅图只能属于一类，而不能同时包含一条狗和一只大象</li><li>输入：<br>(1) logits: 数据类型（type）是float32或float64，维度(shape)为[batch_size,num_classes]<br>(2) labels: 和logits具有相同type和shape的张量(tensor)，是一个有效的概率，sum(labels)=1, one_hot=True(向量中只有一个值为1.0，其他值为0.0)</li><li>输出：<br>loss，shape:[batch_size]</li></ul><h3 id="（3）-tf-nn-sparse-softmax-cross-entropy-with-logits"><a href="#（3）-tf-nn-sparse-softmax-cross-entropy-with-logits" class="headerlink" title="（3） tf.nn.sparse_softmax_cross_entropy_with_logits"></a>（3） tf.nn.sparse_softmax_cross_entropy_with_logits</h3><pre><code>tf.nn.sparse_softmax_cross_entropy_with_logits(_sentinel=None,labels=None,logits=None, name=None)</code></pre><ul><li>计算方式：对输入的logits先通过softmax函数计算，再计算它们的交叉熵，但是它对交叉熵的计算方式进行了优化，使得结果不至于溢出</li><li>适用：同tf.nn.softmax_cross_entropy_with_logits()</li><li>输入：<br>(1) logits: 数据类型（type）是float32或float64，维度(shape)为[batch_size,num_classes]<br>(2) labels：shape为[batch_size],labels[i]是{0,1,2,……,num_classes-1}的一个索引, type为int32或int64</li><li>输出：<br>loss，shape:[batch_size]</li></ul><p>Notes:此函数是tf.nn.softmax_cross_entropy_with_logits()的易用版本，这个版本的logits的形状依然是[batch_size, num_classes]，但是labels的形状是[batch_size, 1]，每个label的取值是从[0, num_classes)的离散值，这也更加符合我们的使用习惯，是哪一类就标哪个类对应的label。<br>如果已经对label进行了one hot编码，则可以直接使用<br>tf.nn.softmax_cross_entropy_with_logits()</p><h3 id="4-tf-nn-weighted-cross-entropy-with-logits"><a href="#4-tf-nn-weighted-cross-entropy-with-logits" class="headerlink" title="(4) tf.nn.weighted_cross_entropy_with_logits"></a>(4) tf.nn.weighted_cross_entropy_with_logits</h3><pre><code>tf.nn.weighted_cross_entropy_with_logits(labels, logits, pos_weight, name=None)</code></pre><ul><li>计算方式：计算具有权重的sigmoid交叉熵sigmoid_cross_entropy_with_logits()</li><li>输入：<br>(1) logits: 数据类型（type）是float32或float64，维度(shape)为[batch_size,num_classes]<br>(2) labels: 和logits具有相同的type(float)和shape的张量(tensor)<br>(3) pos_weight: 正样本的一个系数</li><li>输出：<br>loss，shape:[batch_size,num_classes]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tensorflow之函数&quot;&gt;&lt;a href=&quot;#Tensorflow之函数&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow之函数&quot;&gt;&lt;/a&gt;Tensorflow之函数&lt;/h1&gt;&lt;h2 id=&quot;1-生成函数&quot;&gt;&lt;a href=&quot;#1-生
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 入门</title>
    <link href="http://yoursite.com/2018/10/06/Markdown-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/10/06/Markdown-入门/</id>
    <published>2018-10-06T13:51:04.000Z</published>
    <updated>2018-10-07T07:24:35.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>&emsp;&emsp;Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。<br>&emsp;&emsp;由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><pre><code># 这是一级标题## 这是二级标题...#### 这是四级标题（共支持6级）</code></pre><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h3><p>Markdown 支持有序列表和无序列表。</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，如：</p><pre><code>* Red* Green* Blue</code></pre><p>显示如下：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字接着一个英文句点，如：</p><pre><code>1. Bird2. McHale3. Parish</code></pre><p>显示如下：</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符</p><h3 id="3-代码区块"><a href="#3-代码区块" class="headerlink" title="3. 代码区块"></a>3. 代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进4个空格或是1个制表符就可以，例如，下面的输入：</p><pre><code>这是一个普通段落：    这是一个代码区块。</code></pre><p>显示如下：<br>这是一个普通段落：</p><pre><code>这是一个代码区块。</code></pre><p>另外两行(```)之间的区域也是代码区块，如：<br>    ```<br>    这里是代码区块<br>    ```<br>显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是代码区块</span><br></pre></td></tr></table></figure></p><h3 id="4-强调"><a href="#4-强调" class="headerlink" title="4. 强调"></a>4. 强调</h3><p>Markdown 使用星号（*）和底线（_）作为标记强调字词的符号。</p><pre><code>*single asterisks*_single underscores_**double asterisks**__double underscores__</code></pre><p>显示如下：<br><em>single asterisks</em></p><p><em>single underscores</em></p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><pre><code>![图片名称](http://gitcafe.com/image.png)![图片名称](/path/to/img.jpg)</code></pre><p><img src="/images/test.jpg" alt="这是一个图片"></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><pre><code>[链接名称](https://github.com)</code></pre><p><a href="https://github.com" target="_blank" rel="noopener">github</a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>&gt; 第一行引用&gt; 第二行引用</code></pre><blockquote><p>第一行引用<br>第二行引用</p></blockquote><h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><pre><code>***或* * *或- - -等等。</code></pre><hr><hr><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p><pre><code>Use the `printf()` function.</code></pre><p>显示如下：<br>Use the <code>printf()</code> function.</p><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><pre><code>缩进空格用&amp;emsp;实现缩进空格用&amp;ensp;实现缩进空格用&amp;nbsp;实现</code></pre><p>呈现效果：<br>缩进两个空格用&emsp;实现<br>缩进四个空格用&ensp;实现<br>缩进八个空格用&nbsp;实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：J
      
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
</feed>
